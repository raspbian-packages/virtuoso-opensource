/*! \page vad_qanda Q-A

\subsection vad_qanda_1 Q1

Q: (Orri Erling)
How wil we do the incremental create table? That is, adding columns etc?
This seems to be the only thing you can't do in pL.

A:
I can't invent now anything better than writing of library of functions like
DB.DBA.VAD_CREATE_TABLE, DB.DBA.VAD_ALTER_TABLE_ADD_COLUMN etc., with predefined names for them.
They may be used both for VAD operations and just in plain applications. Being standardized, they
may be generated by graphical schema editor like Star Designer (or maybe AccessV ?)
I can do any schema modification in exec() call, catching all errors and having full control over
the result. A stupid but working example is DB.DBA.RDF_RECREATE_NODEID_TABLE in
binsrc/samples/odp/rdf_lib.sql .

\subsection vad_qanda_2 Q2

Q: (Orri Erling)
Otherwise what is the inplementation timeframe?
What if the package format were a single XML tree with all bits inside and a checksumm at the
end.
The XML electronic signature standard will anyway be supported so that would take care of that.
Binary items could just be cdata's encoded somehow. 
 
Then picking up the bits and putting them into the format would be a recursive traversal of the
sticker while constructing an isomorphous tree with the actual data.

A:
I've made this decision, having three ideas in my brain (not so much...).

1. In many cases before, I have seen a need to fetch something from the installation package
without running a whole installation routine. Any installer usually have a tiny backdoor to get a
couple of files. Microsoft has an "extract.exe", Borland provides "unpaq.com" etc. It may be just
an inertial sort of thinking, but I afraid we will need something similar, too. All we will need
for this structure of package is fseek, fread, guncompress and fwrite. 

2. For our purposes, we already have a BIF function to read N bytes starting from Mth byte of file
F, and ready-to-use gzipping. But if we want to put everything into XML, we need to add encoding
for binaries in XML and XML signature, and we may be unable to create a whole XML by one running
of XSLT, as we will be able for text-only sticker.

3. There's a nice method: to write some functionality, like in "minizip" sample of gzip library,
to read/write ZIP directory from BIFs. It is the best thing among others because the interface
provided will be commonly useful for applications. But to keep it commonly useful, we may need to
track updates in ZIP standards, possibly violating the compartibility of VAD packages of different
versions. I decided not to use ZIP, remembering "The Stroustrup's Rule" -- "Any two notations
should be either absolutely identical in their common part or be very different, but not similar."

\subsection vad_qanda_3 Q3

Q: (Boris Muratsin)
Very interesting moment is the resolving of conflicts between packages.
If installation (or de-installation) is impossible, we nevertheless have possibility to find 
all appropriate ways to do it. E.g: install some additional packages, change versions or 
uninstall some packages. This requires large counting and it is preferrable to do it on C 
rather than on PL. Still one reason: there can be too deep recursion.

A:
It's easy to explain why something is impossible,
just because the description of failed check is the answer we need.
We obviously cannot provide a detailed instruction how to do the operation admin need:
<UL>
<LI>If package C requires B, we can emit a message about it, but we cannot say that
B will requires A if we have no B package at hand. </LI>
<LI>If package C requires B, and we know that B will require A, we still cannot predict
that A will conflict with already installed package X. </LI>
<LI>If the conflict will be detected by application-specific SQL code, we can't predict it. </LI>
</UL>

I think that we should restrict the troubleshooting by typical 
"...correct the errors listed above and try again".

\subsection vad_qanda_4 Q4

Q: (Boris Muratsin)
What about the running VAD in some other account then 'dba' e.g.: special account 'vad'?

A:
How to grant and revoke privileges, change the web-server's security etc.
without having admin rights?

\subsection vad_qanda_5 Q5

Q: (Boris Muratsin)
What about patches to packages? And packages upgrade? And re-install? 
Sometimes it is impossible to de-install existing package to do it.

A:
These issues are reflected somehow in the spec. More precise questions required.

\subsection vad_qanda_6 Q6

Q: (Boris Muratsin)
There is no reasons to trust the pakage's sticker. 
There can be mismatch in sticker's and package's content.
Do we need some temporary place to put all package's data with resource reservation at time of sticker parsing?

A:
There's no need to do this:
<UL>
<LI>The integrity of the package may be checked once at the beginning of a VAD operation. </LI>
<LI>The whole sticker may be retrieved into one temporary XPER entity,
and we will have search and random access to its parts during the whole operation. </LI>
<LI>We can check if we may install all files before actual deployment of the first one. </LI>
</UL>

\subsection vad_qanda_7 Q7

Q: (Boris Muratsin)
What about the life cycle of a package? How to compose the 'scratch' to run 'VAD_PACK'?
What is the content of this 'scratch'? 

A:
It may be convenient to have just an development installation, used for plain testing of
the application, plus a hand-written sticker.
Some parts of the sticker may be created at least "semi-", maybe "fully-" automatically,
and incorporated into hand-writen part via external generic entities (we have 
<CODE>group</CODE> element, see \ref vad_sticker_dtd_top).
<UL>
<LI>It's easy to create the registry element of the sticker via regedit.vsp. </LI>
<LI>It may be possible to create a skeleton of ddl element by
diffing the schema of the database with the application agains the schema of the database
with all required packages installed, but without the application itself. </LI>
<LI>Diffing of directories may produce the lsit of file resources. </LI>
</UL>

\subsection vad_qanda_8 Q8

Q: (Boris Muratsin)
A vad-package has the set of states. 
E.g:
	- 'published-somewhere-but-unknown-for-this-server': referenced by other package, for example
	- 'available-via-uri'
	- 'unpacked-into-temporary-space-but-not-activated': if some authorisation is required
	- 'activated'
	- 'partially-deactivated': to save docs, for example
	- 'under-construction': the scratch itself

How does it been represented in registry?

A: Only 'activated' and 'partially-deactivated' packages will be noted in the registry:
<UL>
<LI>'published-somewhere-but-unknown-for-this-server':
No info will be stored:
we don't want to store all tittle-tattles about all packages,
because we cannot use these information.
The using of such information may cause side effects which will be hard for reproduceing at
tech-support side. </LI>
<LI>'available-via-uri':
The spec explicitely does not cover question of packages' shipment.
Again, the using of such information may cause side effects and security violations
(if the URI will be substituted to guide administrator to fake vendor. </LI>
<LI>'unpacked-into-temporary-space-but-not-activated':
We will have no temporary space. </LI>
<LI>'activated':
The package installed will have its branch in the registry, with sticker and current status inside. </LI>
<LI>'partially-deactivated':
Yes, docs will be described in a separate branch, not affected by uninstall.
See \ref vad_registry_DOCS. </LI>
<LI>'under-construction':
The scratch is not an testable application.
It is not something installed by VAD, so we cannot garantee anything. </LI>
</UL>

\subsection vad_qanda_9 Q9

Q: (Boris Muratsin)
Still about sticker. 
Do we need the mechanism of authomatic sticker generation as inverse to 'sticker's checking'/'package install' operation?
Simple solution - XML view around the vad-registry. 
In such a way we can use it as validator in a package construction with clear error descriptions.

A:
Yes, we will generate some portions of stickers by robots. See \ref vad_qanda_7.

*/